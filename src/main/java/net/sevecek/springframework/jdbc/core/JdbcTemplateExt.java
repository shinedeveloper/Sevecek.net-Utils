package net.sevecek.springframework.jdbc.core;

import java.sql.*;
import java.util.*;
import javax.sql.*;
import org.springframework.dao.*;
import org.springframework.jdbc.core.*;
import org.springframework.jdbc.support.*;
import org.springframework.util.*;

public class JdbcTemplateExt extends JdbcTemplate {

    public JdbcTemplateExt() {
        super();
    }


    public JdbcTemplateExt(DataSource dataSource) {
        super(dataSource);
    }


    public JdbcTemplateExt(DataSource dataSource, boolean lazyInit) {
        super(dataSource, lazyInit);
    }


    /**
     * <p>
     *   This is a combination of JdbcTemplate.update(PreparedStatementCreator, KeyHolder)
     *                       and  JdbcTemplate.update(PreparedStatementCreator, PreparedStatementSetter)
     * </p>
     *
     * <p>
     *   Issue an update statement using a PreparedStatementCreator to provide SQL and
     * PreparedStatementSetter to set bind parameters with given SQL.
     * Generated keys will be put into the given KeyHolder.
     * </p>
     * <p>
     *   Note that the given PreparedStatementCreator has to create a statement
     * with activated extraction of generated keys (a JDBC 3.0 feature). This can
     * either be done directly or through using a PreparedStatementCreatorFactory.
     * </p>
     *
     * @param psc object that provides SQL and any necessary parameters
     * @param pss helper that sets bind parameters. If this is <code>null</code>
     * we run an update with static SQL.
     * @param generatedKeyHolder KeyHolder that will hold the generated keys
     * @return the number of rows affected
     * @throws DataAccessException if there is any problem issuing the update
     * @see PreparedStatementCreatorFactory
     * @see org.springframework.jdbc.support.GeneratedKeyHolder
     */
    public int update(PreparedStatementCreator psc, final PreparedStatementSetter pss, final KeyHolder generatedKeyHolder)
            throws DataAccessException {

        Assert.notNull(generatedKeyHolder, "KeyHolder must not be null");
        logger.debug("Executing SQL update and returning generated keys");

        Integer result = execute(psc, new PreparedStatementCallback<Integer>() {
            @Override
            public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException {
                try {
                    if (pss != null) {
                        pss.setValues(ps);
                    }

                    int rows = ps.executeUpdate();

                    List<Map<String, Object>> generatedKeys = generatedKeyHolder.getKeyList();
                    generatedKeys.clear();
                    ResultSet keys = ps.getGeneratedKeys();
                    if (keys != null) {
                        try {
                            RowMapperResultSetExtractor<Map<String, Object>> rse =
                                    new RowMapperResultSetExtractor<Map<String, Object>>(getColumnMapRowMapper(), 1);
                            generatedKeys.addAll(rse.extractData(keys));
                        } finally {
                            JdbcUtils.closeResultSet(keys);
                        }
                    }
                    if (logger.isDebugEnabled()) {
                        logger.debug("SQL update affected " + rows + " rows and returned " + generatedKeys.size() + " keys");
                    }
                    return rows;
                } finally {
                    if (pss instanceof ParameterDisposer) {
                        ((ParameterDisposer) pss).cleanupParameters();
                    }
                }
            }
        });
        return result.intValue();
    }


    /**
     * Issue a single insert statement using the provided SQL and
     * optional bind parameters via a prepared statement.
     * Generated keys will be put into the given KeyHolder.
     *
     * @param sql SQL containing bind parameters
     * @param args arguments to bind to the query
     * (leaving it to the PreparedStatement to guess the corresponding SQL type);
     * may also contain {@link SqlParameterValue} objects which indicate not
     * only the argument value but also the SQL type and optionally the scale
     * @param keyHolder KeyHolder that will hold the generated keys
     * @return the number of rows affected
     * @throws DataAccessException if there is any problem issuing the update
     * @see org.springframework.jdbc.support.GeneratedKeyHolder
     */
    public int insert(String sql, KeyHolder keyHolder, Object... args) throws DataAccessException {
        return update(new AutoGeneratedKeysPreparedStatementCreator(sql), newArgPreparedStatementSetter(args), keyHolder);
    }


    /**
     * Issue a single insert statement using the provided SQL and
     * optional bind parameters via a prepared statement.
     * Generated keys will be put into the given KeyHolder.
     *
     * @param sql SQL containing bind parameters
     * @param keyHolder KeyHolder that will hold the generated keys
     * @param args arguments to bind to the query
     * @param argTypes SQL types of the arguments
     * (constants from <code>java.sql.Types</code>)
     * @return the number of rows affected
     * @throws DataAccessException if there is any problem issuing the update
     * @see org.springframework.jdbc.support.GeneratedKeyHolder
     * @see java.sql.Types
     */
    public int insert(String sql, KeyHolder keyHolder, Object[] args, int[] argTypes) throws DataAccessException {
        return update(new AutoGeneratedKeysPreparedStatementCreator(sql), newArgTypePreparedStatementSetter(args, argTypes), keyHolder);
    }


    /**
     * This is copied from SimplePreparedStatementCreator (JdbcTemplate source code).
     * If it changes, this needs too! <br/><br/>
     *
     * The only difference is <code>con.prepareStatement(this.sql, <b>Statement.RETURN_GENERATED_KEYS</b>)</code>;
     */
    public static class AutoGeneratedKeysPreparedStatementCreator implements PreparedStatementCreator, SqlProvider {

        private final String sql;


        public AutoGeneratedKeysPreparedStatementCreator(String sql) {
            Assert.notNull(sql, "SQL must not be null");
            this.sql = sql;
        }


        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
            return con.prepareStatement(this.sql, Statement.RETURN_GENERATED_KEYS);
        }


        @Override
        public String getSql() {
            return this.sql;
        }
    }

}
